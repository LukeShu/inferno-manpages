.TH 0INTRO 14
.PP
.SH NAME
Limbo Math Module
.SH SYNOPSYS
.PP
   *   *   *   *   *
.PP
The 
.I math.m
module provides primitives for scientific computing including control of the floating point environment, elementary functions of applied mathematics, and linear algebra operations.
The Limbo Math modules area as follows:
.PP
.TS
tab(@);
l.
T{
.I elem \- elementary functions of applied mathematics

T}
T{
.I fp \- floating point operations

T}
T{
.I linalg \- linear algebra primitives

T}
.TE
.PP
.TS
tab(@);
l.
T{
T}
.TE
.PP
.SH SYNOPSIS
.IP
.EX
include \[dq]math.m\[dq];
math:= load Math Math\->PATH;
.EE
.PP
.SH DESCRIPTION
Inferno\[aq]s math module and Limbo compiler provide the fundamental floating point environment and elementary functions.
.PP
Limbo expressions involving only literal and named constants are evaluated at compile time with all exceptions ignored.
However, arithmetic on variables is left to run\-time, even if data path analysis shows the value to be a compile time constant.
This implies that tools generating Limbo source must do their own simplification, and not expect the compiler to change 
.I x/x
into 1, or 
.I \-(y\-x)
into 
.I x\-y
, or even 
.I x\-0
into 
.I x
.
Negation, \-x, changes the sign of x, as opposed to computing 0.
.I \-x
, which gives a different result for 
.I x=0
.
.PP
Subexpression elimination and other forms of code motion may be done by the compiler, but not across calls to the mode and status functions described in 
.I fp \- floating point operations
.
Removal of parentheses or factoring is not performed by the compiler.
The evaluation order of 
.I a+b+c
follows the parse tree and is therefore the same as for 
.I (a+b)+c
.
These rules are the same as for Fortran and the C language.
.PP
Contracted multiply\-add instructions with a single rounding are not generated by the compiler, though they may be used in the native BLAS (linear algebra) libraries.
All arithmetic follows the IEEE floating point standard, except that denormalized numbers may be replaced by flush\-to\-0, depending on what the hardware makes feasible.
.PP
Binary/decimal conversion is properly rounded.
In particular, printing a real number using 
.I %g
and reading it on a different machine is guaranteed to recover identical bits, including conversions done by the compiler.
The one exception is that smaller, faster, but less exact run\-time conversion routines may be used when mandated by limited memory embedded systems.
Programmers can assume, however, that the features described here are present in all Inferno systems intended for general computing.
